3/24: We found that we have to check if the tables already exists in the database before creating tables or else everytime the server starts it will try to create new tables and there will be errors.
3/25: Since we were using python to parse xml, we found that we have to jump over the starting number in every request for the parser library to correctly recognize the string as xml
3/27: We found that we have to check if the columns exists before altering table and adding symbol to the account table, so in order to use the "IF NOT EXISTS" syntax we switched to postgres 11.
3/29: We found that for an order to be valid, we have to check if the requested symbol already exists in the account table. Also in the execution process, if the new order can be matched to an existing open order, the same transaction id need to be used to create a new "executed" transaction entry in the table if the order was partially executed. If the order is executed fully, only its status need to be edited and time stamp need to be added.
3/31: We found that when we were building the xml tree for the response, all the integer fields in the database need to be transformed into string before being passed into the xml tree.
4/2: We found that for the execution operations to be atomic, we have to put the one commit after every query(deduct money, deduct shares, edit order status, add time stamp etc.) so that if something is wrong with any of those operations, none of the changes will be committed to the database.
4/3: We found that when we were dockerizing the project, two containers need to be created, one for postgresql and one for our server. Also the server container must start after the db container is fully up and ready. So we added "restart:always" to the server container for it to restart if db was not ready and something failed. Also we bind the server inside the container to 0.0.0.0 and exposed port 12345 so that client from outside the container can connect to the server.